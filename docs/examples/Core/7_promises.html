<!DOCTYPE html>
<html>
<head>
    <title>KUBEjs Core: KUBE.Promise()</title>
    <!-- Include KUBE.js -->
    <script src="../../../src/KUBE.js"></script>

    <!-- KUBE.Is is a part of KUBE.js and therefore does not require loading -->
    <script type="text/javascript">

        /*
         *  KUBE.Promise is a fairly standard promise library. It was a late addition to KUBEjs so has not been heavily used, and is still slightly incomplete
         *  KUBE.Promise takes an executor callback and returns a promise object with then/catch
         *
         *  API includes: (lowercase is how it is traditionally done, upper case is the KUBE style for public methods)
         *      -then/Then
         *      -catch/Catch
         */

        //1
        var Promise = KUBE.Promise(function(_resolve,_reject){
           //Do async stuff. When done, call _resolve to fire the next resolution callback, or _reject to fire the next reject callback
            setTimeout(function(){
                _resolve('we initially resolve after a half second')
            },500);
        });

        //2
        Promise.then(function(_resolve,_reject,_data){
            //Then also returns a Promise Obj
            console.log(_data);
            setTimeout(function(){
                var E = new Error('we then reject after a half second');
                _reject(E); //If data passed into reject is not an Error object, it is attached to an error object inside of client
            });
        });

        //3
        Promise.catch(function(_resolve,_reject,_Error){
            //Catch also returns a Promise Obj
            console.log(_Error.message);
            _resolve('we can continue the chain even in a rejection');
        });

        //4
        //Then will accept a resolve/reject callback as first/second arg. In this case, only one of the functions will be called, before the chain moves on
        Promise.then(
            function(_resolve,_reject,_data){
                console.log(_data);

                //Also if an error is throw inside of the promise chain, it automatically calls the next rejection
                throw Error('This is an error being thrown');
            },
            function(_resolve,_reject,_Error){
                //This won't be called because we resolved 3
            }
        );

        Promise.catch(function(_resolve,_reject,_Error){
            console.log(_Error.message);
            console.log('We will resolve now but put a delay between this and even binding the next then');
            _resolve('We resolved');
        });

        //5
        //Even though a chain is resolved, this puts it in a state ready to fire. This means an additional 'then' will automatically get fired and start the chain up again
        setTimeout(function(){
            Promise.then(function(_resolve,_reject){
                console.log('The chain has been started again');
                _resolve(); //Finish it again
            });
        },2000);
    </script>

</head>
<body>
Example outputs to console:
</body>
</html>